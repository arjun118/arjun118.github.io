[{"content":"Hey there, good to see you here.\nI\u0026rsquo;ve picked up golang to learn this summer. so I thought building toy projects would be a good way to start with. In the process I stumbled upon gophercises which is arguably one of the best resource to learn to while having fun\nI was trying my hand at building a command line todo tool or task list project in gophercises. tbh it\u0026rsquo;s pretty basic but i get to try out boltdb and the cobra tools which helps you in building command line applications faster.\nso this blog (not very technical) is just me reading about it. if you already know about endianness and how juggle with numbers in go, this one is probably not for you (you should skip it)\nTwo sides of Endianness by now, i think , you are familiar with what endianness is and all, if not, please go through this\nour application is very basic, to over simplify , here is the usage\nadd a task\ntodocli add \u0026lt;task_name\u0026gt;\ndo a task\ntodocli do \u0026lt;task_id\u0026gt;\nlist all tasks\ntodocli list\nthat\u0026rsquo;s it, what\u0026rsquo;d i tell you, toy projects!\nwe use boltdb to persist the tasks data.\nas you have already guessed, the only code we need write is to add (write to the tasks db), list (read from the tasks db), do (delete from the tasks db) for now,we are not storing any completed tasks,we just delete them\ni\u0026rsquo;ll just paste the relevant pieces of code we need to write for add functionaly, on which i want focus on right now.\nfunc Add(task string) error{ db, err := bolt.Open(\u0026#34;tasks.db\u0026#34;, 0600, nil) if err != nil { fmt.Println(\u0026#34;Error opening database:\u0026#34;, err) return err } defer db.Close() // add a new task to the db readWriteError := db.Update(func(tx *bolt.Tx) error { b, er := tx.CreateBucketIfNotExists([]byte(\u0026#34;tasks\u0026#34;)) if er != nil { return er } id, _ := b.NextSequence() fmt.Println(id) fmt.Println(itob(int(id))) err = b.Put(itob(int(id)), []byte(task)) if err != nil { fmt.Printf(\u0026#34;Could not write task to the database: %s\u0026#34;, err) return err } return nil }) if readWriteError != nil { fmt.Println(\u0026#34;Error writing to database:\u0026#34;, readWriteError) return readWriteError } fmt.Println(\u0026#34;Task added:\u0026#34;, task) return nil } func itob(v int) []byte { b := make([]byte, 8) binary.BigEndian.PutUint64(b, uint64(v)) fmt.Println(\u0026#34;itob:\u0026#34;, v, b) return b } i\u0026rsquo;ll simplify the things i don\u0026rsquo;t want you to focus on.\nid, _ := b.NextSequence() let\u0026rsquo;s just say you already have 3 tasks in your db, and the task_id of the last task is 3. now when you try to add a new task, the id variable will have the value 4 indicating the next task\u0026rsquo;s id that is to be added\nlet\u0026rsquo;s focus on this piece of code\nerr = b.Put(itob(int(id)), []byte(task)) if we take a step back and look at Put in boltdb\u0026rsquo;s documentation, we\u0026rsquo;d find\nlooking by the signature ,we can make out that we need to provide a slice of bytes as our key and as our value\nthis is where we need to convert our task_id which is an integer to a slice of bytes. we can convert this into big endian representation or small endian representation while storing in the db\nlet\u0026rsquo;s see how we can convert int into big endian and little endian representations\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;encoding/binary\u0026#34; ) func itob(v int) ([]byte, []byte) { be := make([]byte, 8) le:= make([]byte, 8) binary.BigEndian.PutUint64(be, uint64(v)) binary.LittleEndian.PutUint64(le, uint64(v)) return be,le } func main(){ x:=255 be,le:= itob(x) fmt.Printf(\u0026#34;value: %d, big endian representation: %v\\n\u0026#34;,x,be) fmt.Printf(\u0026#34;value: %d, little endian representation: %v\\n\u0026#34;,x,le) } output\nvalue: 255, big endian representation: [0 0 0 0 0 0 0 255] value: 255, little endian representation: [255 0 0 0 0 0 0 0] this is straight forward cause, byte is a synonym of uint8 datatype in go, hence we can store a maximum of 255 in one instance of a byte\nsince 255 is represented as 1 1 1 1 1 1 1 1 1 now this byte when represented in big endian, (uint64, which occupies 8 bytes) 00000000 00000000 000000000 000000000 000000000 000000000 000000000 11111111\nin big endian,the msb (most significant byte) occupies the lowest memory address, while in little endian, the lsb (least significant byte) occupies the lowest memory address\nhence in big endian this becomes 0 0 0 0 0 0 0 255, the same way little endian comes out as 255 0 0 0 0 0 0 0\nlet\u0026rsquo;s see one more example, x=1921\nvalue: 1921, big endian representation: [0 0 0 0 0 0 7 129] value: 1921, little endian representation: [129 7 0 0 0 0 0 0] in uint64 1921 is represented as\n00000000 00000000 00000000 00000000 00000000 00000000 00000111 10000001\ni hope that, now it\u0026rsquo;s corresponding big and little endian representations make sense\nAlright, this is a very short, vauge blog. I wanted to write about something hence this exists.\nNote: big endian is used here. It\u0026rsquo;s often used in BoltDB for ordering purposes. BoltDB stores keys as []byte and compares them lexicographically (byte-by-byte from left to right). hence the numeric order of the keys is preserved naturally\n","permalink":"https://arjun118.github.io/technical/little_and_big_endian_in_go/","summary":"\u003cp\u003eHey there, good to see you here.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;ve picked up golang to learn this summer. so I thought building toy projects would be a good way to start with. In the process I stumbled upon \u003ca href=\"https://courses.calhoun.io/courses/cor_gophercises\"\u003egophercises\u003c/a\u003e which is arguably one of the best resource to learn to while having fun\u003c/p\u003e\n\u003cp\u003eI was trying my hand at building a command line todo tool or task list \u003ca href=\"https://courses.calhoun.io/lessons/les_goph_35\"\u003eproject in gophercises\u003c/a\u003e. tbh it\u0026rsquo;s pretty basic but i get to try out boltdb and the cobra tools which helps you in building command line applications faster.\u003c/p\u003e","title":"Little and Big Endian in Go"},{"content":" This blog assumes that you are familiar with docker and it\u0026rsquo;s basic concepts such as volumes (that\u0026rsquo;s the only concept we gonna use either way ðŸ˜…).\nWe have a flask application which is basically a social blogging site where users can register, login (ofcourse), make posts, comment, follow other users and with role based authentication implemented for granting appropriate permissions for users, moderators and admins.\nFollowing the good practice of using a separate python virtual environments to work on different projects, i\u0026rsquo;ve created a virtual environment using the venv python module and built my application in that environment so i could keep my projects\u0026rsquo; isolated\nThis is how my script.py, which is the starting point of the flask application looks like. Your\u0026rsquo;s might look different and it\u0026rsquo;s perfectly alright!. you can ignore FLASK_CONFIG for now, the \u0026lsquo;default\u0026rsquo; value for FLASK_CONFIG indicates that the current environment is a developement one and not a prod one\nimport os from app import create_app, db from app.models import User, Role from flask_migrate import Migrate app=create_app(os.getenv(\u0026#39;FLASK_CONFIG\u0026#39;) or \u0026#39;default\u0026#39;) migrate=Migrate(app,db) with app.app_context(): db.create_all() Role.insert_roles() @app.shell_context_processor def make_shell_context(): return dict(db=db, User=User, Role=Role) if __name__==\u0026#39;__main__\u0026#39;: app.run() look at these three lines of code\nwith app.app_context(): db.create_all() Role.insert_roles() as mentioned earlier, i\u0026rsquo;ve implemented role based authentication (RBAC), you dont need to do Role.insert_roles() if you do not have any roles to begin with. But you still need to create all the database tables if you are using a database\nThe way db.create_all() works is that if a particular table related to a model does not exist in the database, it creates that table in the database. However, if a table associated with the model already exists, it won\u0026rsquo;t create a new table.\nKeep in mind, we need to create the database tables inside the application context of our app or else simply running db.create_all() won\u0026rsquo;t work\nNow let\u0026rsquo;s take a look at the Dockerfile\nFROM python:alpine RUN adduser -D cicada # you can change ths user too! USER cicada ENV FLASK_APP=script.py # replace script.py with the appropriate filename in your project WORKDIR /home/cicada COPY requirements.txt requirements.txt RUN python -m venv venv RUN venv/bin/pip install -r requirements.txt COPY app app COPY migrations migrations COPY script.py config.py boot.sh ./ EXPOSE 5000 ENTRYPOINT [\u0026#34;./boot.sh\u0026#34;] a few points to note here,\nmy directory organization looks like this,(i have omitted out some files intentionally, just wanted to give you guys an idea about the organization)\nâ”œâ”€â”€ Dockerfile â”œâ”€â”€ app â”‚Â â”œâ”€â”€ __init__.py â”‚Â â”œâ”€â”€ auth â”‚Â â”‚Â â”œâ”€â”€ __init__.py â”‚Â â”‚Â â”œâ”€â”€ forms.py â”‚Â â”‚Â â””â”€â”€ views.py â”‚Â â”œâ”€â”€ decorators.py â”‚Â â”œâ”€â”€ main â”‚Â â”‚Â â”œâ”€â”€ __init__.py â”‚Â â”‚Â â”œâ”€â”€ errors.py â”‚Â â”‚Â â”œâ”€â”€ forms.py â”‚Â â”‚Â â””â”€â”€ views.py â”‚Â â”œâ”€â”€ models.py â”‚Â â”œâ”€â”€ static â”‚Â â”‚Â â”œâ”€â”€ favicon.ico â”‚Â â”‚Â â””â”€â”€ styles.css â”‚Â â””â”€â”€ templates â”‚Â â”œâ”€â”€ 403.html â”‚Â â”œâ”€â”€ 404.html â”‚Â â”œâ”€â”€ 500.html â”‚Â â”œâ”€â”€ auth â”‚Â â”‚Â â”œâ”€â”€ login.html â”‚Â â”‚Â â””â”€â”€ register.html â”‚Â â”œâ”€â”€ base.html â”‚Â â”œâ”€â”€ index.html â”‚Â â”œâ”€â”€ profile.html â”‚Â â””â”€â”€ single_post.html â”œâ”€â”€ boot.sh â”œâ”€â”€ config.py â”œâ”€â”€ data-dev.sqlite â”œâ”€â”€ migrations â”œâ”€â”€ requirements.txt â”œâ”€â”€ script.py we are creating a new python environment in the using python -m venv \u0026lt;name_of_the_environment\u0026gt; we are installing all our dependencies in the new environment here the app folder is my main folder where i have the code for my application the contents of boot.sh , which is the entrypoint of our docker image are #!/bin/sh source venv/bin/activate flask run --host 0.0.0.0 --port 5000 the requirements.txt file contains the list of modules/ dependencies that our flask application needs, you run generate this file by using the below command, just remember to activate your virtual environment before generating\nsource \u0026lt;your_environment_name\u0026gt;/bin/activate pip freeze \u0026gt; requirements.txt Now, it\u0026rsquo;s time to build the image. Navigate to the directory where you have your Dockerfile saved and execute this\ndocker build -t flask_app:latest . once the image is built, you can list out the images using (i\u0026rsquo;ve created a while ago)\nâ•°â”€$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE flask_app latest ca0ec641a957 42 minutes ago 129MB let\u0026rsquo;s spin up a container with this image\ndocker run -it -p 8000:5000 --name smapp flask_app:latest we are mapping the port 5000 which will be exposed inside the container to the port 8000 on our host machine, so that we can access the site from http://localhost:8000\nNow you can interact with the website, create a user, publish a post, comment etc.\nBut when you restart the container, all the users, posts, comment which you may have created earlier are lost. This is where the need for volumes come in\nTo ensure data persistence we mount the volume to the container\nlets create a volume\nâ•°â”€$ docker volume create smdata smdata list the available volumes\nâ•°â”€$ docker volume ls DRIVER VOLUME NAME local smdata mounting a volume,\ndocker run -it --name smapp --mount source=smdata,target=/home/cicada -p 8000:5000 flask_app:latest The source parameter specifies the name of the volume. The target parameter defines the folder path inside the container where the volume will be mounted. Now,even if you restart the container, your data will be persistent\nNext, I will try write about how we can do this using docker-compose and an external mysql db\n","permalink":"https://arjun118.github.io/technical/dockerize_a_flask_application/","summary":"\u003cblockquote\u003e\n\u003cp\u003eThis blog assumes that you are familiar with docker and it\u0026rsquo;s basic concepts such as volumes (that\u0026rsquo;s the only concept we gonna use either way ðŸ˜…).\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eWe have a flask application which is basically a social blogging site where users can register, login (ofcourse), make posts, comment, follow other users and with role based authentication implemented for granting appropriate permissions for users, moderators and admins.\u003c/p\u003e\n\u003cp\u003eFollowing the good practice of using a separate python virtual environments to work on different projects, i\u0026rsquo;ve created a virtual environment using the \u003ccode\u003evenv\u003c/code\u003e python module and built my application in that environment so i could keep my projects\u0026rsquo; isolated\u003c/p\u003e","title":"Dockerize a Flask Application"}]